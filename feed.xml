<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.ruo-chen.wang/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.ruo-chen.wang/" rel="alternate" type="text/html" /><updated>2025-08-14T07:34:19+08:00</updated><id>https://blog.ruo-chen.wang/feed.xml</id><title type="html">weirane’s blog</title><subtitle>weirane's blog</subtitle><author><name>weirane</name></author><entry><title type="html">开始读《异见时刻》</title><link href="https://blog.ruo-chen.wang/2024/09/starting-notorious-rbg.html" rel="alternate" type="text/html" title="开始读《异见时刻》" /><published>2024-09-08T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2024/09/starting-notorious-rbg</id><content type="html" xml:base="https://blog.ruo-chen.wang/2024/09/starting-notorious-rbg.html"><![CDATA[<p>打算开始读《异见时刻：“声名狼藉” 的金斯伯格大法官》。这是一本前美国最高法院大法官 Ruth Bader Ginsburg (RBG) 的传记。RBG 是美国最高法院第二位女性大法官。最开始听说 RBG 是在詹青云做客鲁豫的一集播客中（岩中花述 S5E1，03/12/2024）。当时好像正好是在 DC 市里面逛，听到 RBG 的墓就在 arlington national cemetary，本来打算去看看的，结果当时比较晚了就没去。当然后来有时间就去瞻仰了一下 RBG 和她丈夫的墓。</p>

<p><img src="/images/14-starting-notorious-rbg/grave-rbg.jpg" alt="Grave of RBG and her husband" width="646px" class="align-center" /></p>

<p>当时听播客的时候有一个点我印象很深，就是阿詹说 RBG 是一个相信<strong>慢慢努力</strong>的人。因为法律的改变是非常缓慢的，她不会去想着一定要做那些有着划时代意义的大案子，而是一点点地搭建人们对男女不应该区别对待的认知。当 RBG 处在一个保守派占多数的最高法院的时候，她会努力去和保守派法官妥协，就算放弃自己意见中的一些激进的部分，也要去争取保守派的票从而赢得这个 case。在她发现无法胜利的时候，她仍然会站出来并更加努力地表达自己 “I dissent” 的态度，尽管当时的判决并不会改变。这种精神虽然不会在现实中有立即的作用，但也是非常有价值的。比如她在 <em>Ledbetter v. Goodyear Tire &amp;
Rubber Co.</em> 案的反对意见<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>中建议国会立法推翻最高法院的决定，结果在奥巴马当选总统之后就实现了。</p>

<p>正好我最近突然意识到我自己其实就是处在一个 “无法接受微小的进步” 的状态里。很多时候需要去做一些细枝末节的事情，但是我在做的时候会没有意义感，从而无法专心做事。说来我意识到我处在这个状态也是从金刚经中的 “应无所住而生其心” 来的。当时听王德峰讲六祖惠能和神秀的偈句的不<span style="white-space: nowrap;">同<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup></span>，一时间突然意识到我和神秀犯的错误其实是一样的：就是沉浸在小乘佛教的自了汉的境界中了。而要达到大乘菩萨的境界，是需要在现实世界中产生影响，去帮助具体的人，做具体的事的。如果 RBG 只在小乘佛教的境界中，她大可以在一些 5 比 4 的判决中拒绝和保守派的法官妥协，就说我自己坚持了自己的原则，但是以案子的失败作为代价。虽然这样做自己的 “心”
没有 “惹尘埃”，但是除了显得自己境界高没有任何现实的作用。我们意识到万物皆性空之后不能执着于空。</p>

<p>这两周看阿詹和阿庞的直播的时候又重新听到了她们对《异见时刻》的推荐。希望能从书中得到一些来自 RBG 的智慧和 inspiration。</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>https://supreme.justia.com/cases/federal/us/550/618/ <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>https://www.bilibili.com/video/BV1Mu411Z7eN/ <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>weirane</name></author><category term="Humanities" /><category term="读书" /><category term="女性主义" /><category term="RBG" /><category term="中国哲学" /><category term="金刚经" /><summary type="html"><![CDATA[Start reading Notorious RBG]]></summary></entry><entry><title type="html">中美文化差异</title><link href="https://blog.ruo-chen.wang/2024/08/cultural-differences.html" rel="alternate" type="text/html" title="中美文化差异" /><published>2024-08-08T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2024/08/cultural-differences</id><content type="html" xml:base="https://blog.ruo-chen.wang/2024/08/cultural-differences.html"><![CDATA[<p>最近看了不少中国哲学的书和视频，想来结合我的经历说一下我浅薄的理解。我主要看的是复旦的王德峰老师的视频。最开始看王德峰老师是从他的 “中西方文化差异的渊源” 入坑的，然后又陆续看了马克思哲学、阳明心学、艺术哲学等等课程，感觉非常长脑子。他有很多片段在 B 站上都很火，特别是讲金刚经三句义的那一段。有兴趣的可以去搜一搜。</p>

<p>我现在在美国也待了有三年了。就我的感觉来说，中国的文化比较讲究平衡，凡事不做到极致，但是美国恰恰相反。美国人喜欢把所有事情都做到当前认知下的极致，然后就相对地固定下来。好像美国人倾向于相信对于每一件事情，世界上都有唯一最好的一个处理方式。而且一旦我们发现了这个方式，就要一直坚持。如果发现了问题，那就应该在现有方式的基础上修补，而不是去推翻之前已经存在的知识。我印象很深的一个事情就是我在 UCSD 的导师说他相信 “there has to be a best way to design it”。我不记得具体是 design 什么了，但是这种对 “the best way” 的执着当时对我有很大的冲击。</p>

<h2 id="举例">举例</h2>

<p>在别的领域里也可以体现出美国的这种目标明确，努力到极致的文化的例子。</p>

<h3 id="城市规划">城市规划</h3>

<p>我最开始看美国城市（特别是新规划的郊区）的地图的时候有一种感觉，就是感觉规划得非常清晰。你能看出来哪里是住宅区，哪里是商业区，哪里是医院，哪里是公园等等，在地图上非常清晰地用不同颜色标注出来了。而看国内城市的地图的时候就会发现好像所有东西是交织在一起的。我的猜想是，由于美国需要用概念和逻辑来找到那个 “最好” 的规划方案，把城市划分成不同的单一功能的区域可以显著降低在规划过程中的复杂度。由于推理的单位从单个的楼房变成了一片区域，他们在规划的过程中需要处理的变量也就更少了，也就更方便了。</p>

<p>但是这种单一功能的规划也会产生问题。这种规划会导致大多数人无法只通过走路从一个区到另一个区。比如住在 single family house 的人无法走路去一个 plaza 买菜。所以造成干什么都要开车的现象。有调查显示在美国，一半的行程是小于五公里的，但是就算这种短距离的出行需求也只能开车，这就加剧了交通的拥堵。所以现在美国又在研究新的模式，比如 <abbr title="Transit-oriented development">TOD</abbr> 就是一个最近很热的概念。</p>

<h3 id="汽车文化">汽车文化</h3>

<p>汽车文化应该是美国最核心的文化之一了。而开车本身就是一个目标非常明确的活动。你需要在脑子里想好一个目的地，然后可能要在地图软件里输入它，然后你就（像一个机器一样地）跟着地图的指引开车。开车和走路不同，开车的时候你无法自由地改变你的行进方向，也不能随时停下休息或者看风景。</p>

<p>有人可能说开车和走路不具备可比性，因为开车可达的半径比走路大多了。那如果我们把开车和乘坐公共交通比较的话，就会发现美国的汽车文化还是会导致你出行的目的性非常强。虽然乘坐公共交通也需要你有一个目的地，但是你的目的地是一大片区域，而不是某一个餐馆或商店。在美国的郊区，你开车到达一个 plaza 停下后，你的目标是很清晰的：我就是要去这个餐厅吃饭。吃完饭之后就回到车上了，你就又需要重新有意识地 “决定” 你的下一个目的地是哪里。如果是在城区选择乘坐公共交通，你在下车之后是一定会走一段路的，而且你的目的地在绝大部分情况下并不是某一个商店，而是一个行人友好的商圈。你在这个商圈中是可以自由地行走的，而且你在自由地行走的过程中会碰到各种意想不到的事情。说不定你看中了某个商店想进去逛逛，或者是你恰好碰到了一个好朋友。这种事情在美国郊区去哪儿都要开车的情境下是很难发生的。</p>

<h3 id="专业性">“专业性”</h3>

<p>最近还看了 Gad Elmaleh 在 Netflix 上的单口专场 American Dream（强推），里面提到了他作为一个法国移民在美国感受到的文化冲击。他说的很多东西都可以用做事到极致来概括。</p>

<p>他提到他在美国遇到了一个工作非常认真尽责的商场的导购。他想让导购帮忙找一件毛衣，导购找了半天回来很伤心地说没有找到，他正想安慰的时候导购突然说他再去 double
check 一下，这让 Gad 非常惊讶，因为法国导购甚至不会 single check。首先这个故事可能有艺术加工的部分，但是一定程度上还是能反映美国人对工作的态度的。当然也可以说这是一种专业性的体现，但是专业性本身就是一种 “做事到极致”。我发现我现在有点反感这种专业性，因为过度的追求专业性其实是非常 dehumanizing 的，是一种对人的异化。我自己也在尝试去寻找这个平衡点应该在哪里，让我在保持专业性的同时也让它在一个可接受的程度里。</p>

<!-- 他还说道美国人对所有的事情都有专用的词来形容。 -->

<h2 id="为什么呢">为什么呢</h2>

<p>美国是一个很新的国家，没有什么历史，也没有什么包袱，所以它可以从零开始，但是这也意味着美国社会的共识是很少的。所以美国需要用最底层的语言和理性来构筑这个社会。只要是语言可以概括的东西一定要表达得很清楚。之前也看过一个说法是由于美国是各地的移民组成的国家，所以形成了一种 low context culture，所以需要尽量用语言把话说得很明白。</p>

<h2 id="感受">感受</h2>

<p>感觉美国人每天都活在一个巨大的实验室里。几乎所有的行为都和 “科学研究” 的结果相关，依照逻辑的推理来做各种决定。比如在政治竞选中，你可以很清晰地说出哪些 “议题” 是你关心的，你的 “立场” 是什么，美国人有各种各样的词语来形容世间万物。其实我是很佩服这种 “我命由我不由天” 的精神和希望改造世界的精神的。</p>

<p>美国社会的模式很像加密货币使用的模式。加密货币有价值是因为它用了算力作为壁垒。因为算力不是一个容易获得的资源，所以算力所产出的加密货币才有价值，尽管不存在一个中央银行来管控货币。而美国的模式就是先假设所有人都是自私的，然后每个人都为自己的利益奋斗。因为人的智力、能力等等不是一个容易获得的资源，所以不需要一个中心的权威来告诉人们资源该怎么分配，而是说赢了这个博弈游戏的人获得资源。</p>

<p>东西方哲学也很像 lambda calculus 和图灵机之间的关系。两者其实都是宇宙的真理，只不过一个自上而下，一个自下而上。但是归根到底两者是等价的，描述的都是人世间的规律。马克思说资本主义发展到最后一定会进入社会主义。我的一个理解可以说是资本主义是指科学的，使用抽象概念，注重达到抽象指标的发展，而社会主义是更加人本的发展。其实现在在美国也在往这方面进步。比如说医疗保险里面处方药的价格是按能吃多少天计算的，也就是说它规定好了无论你吃什么药，你有一个固定的预期每个月需要花多少钱，这就是更加人本的模式。但是我们怎么才能达到这种更加人本的发展模式呢？可能也只能借鉴西方的发展模式。就像 lambda calculus 非常抽象，但是我们可以用图灵机去实现它。</p>

<h2 id="相关阅读">相关阅读</h2>

<ul>
  <li>Amy Ko 的博客文章：<a href="https://amyjko.medium.com/cars-are-unjust-16f0fc86a851" class="external">Cars are unjust</a></li>
  <li>我有一篇讲 lambda calculus 的博客：<a href="/2021/04/lambda-calculus-from-the-ground-up.html" class="external">链接</a></li>
  <li>城市规划和公共交通的 YouTube Channel: <a href="https://www.youtube.com/@NotJustBikes" class="external">Not Just Bikes</a></li>
  <li>王德峰老师的 <a href="https://space.bilibili.com/514924891" class="external">B 站主页</a></li>
  <li><a href="https://www.netflix.com/title/80170187" class="external">Gad Elmaleh: American Dream</a></li>
</ul>]]></content><author><name>weirane</name></author><category term="Humanities" /><category term="中国哲学" /><category term="草台班子" /><category term="单口喜剧" /><category term="城市规划" /><category term="lambda-calculus" /><summary type="html"><![CDATA[Cultural differences between China and the US]]></summary></entry><entry><title type="html">关于基于表达式的编程语言的一些思考</title><link href="https://blog.ruo-chen.wang/2021/12/functional.html" rel="alternate" type="text/html" title="关于基于表达式的编程语言的一些思考" /><published>2021-12-25T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2021/12/functional</id><content type="html" xml:base="https://blog.ruo-chen.wang/2021/12/functional.html"><![CDATA[<p>最近学 Go 语言又想起之前看过的一个 talk，presenter 说他几乎不用 <code>else</code> 关键字。因为一般情况下，if 语句的其中一个 branch 会比较短（比如处理特殊情况），这样可以在这个 branch 结束后直接从函数返回，后续的代码就不需要进行缩进了，如</p>
<pre><code class="language-go">func fact(n int) int {
    if n &lt;= 1 {
        return 1
    }
    // no extra indent here!
    return fact(n - 1) * n
}
</code></pre>

<p>可以减少缩进当然是件好事。如果后续代码很长可以采用这种风格。但我觉得并不是所有的情况都适用于这种写法。相比之下我更喜欢这样的写法</p>
<pre><code class="language-c">int fact(int n) {
    return n &lt;= 1 ? 1 : fact(n - 1) * n;
}
</code></pre>
<p>或者使用 <code>else</code></p>
<pre><code class="language-rust">fn fact(n: i32) -&gt; i32 {
    if n &lt;= 1 {
        1
    } else {
        fact(n - 1) * n
    }
}
</code></pre>

<p>Go 语言里没有三目运算符，因为语言设计者认为滥用三目运算符可能会降低可读性 <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>。三目运算符的可读性确实没有 if 语句高，但是问题的核心其实不在三目运算符。三目运算符的鼻祖 C 需要它是因为 C 的 if 语句不是一个表达式，所以需要一个新的语法来表示
if 表达式。相比很多语言就不需要三目运算符，因为它们的 if 本身就是一个表达式。同时 if 语句的可读性也比三目运算符高不少，用 <code>else if</code> 再添加几个 branch 也不会降低可读性。</p>

<p>对我来说基于表达式可以让代码更容易理解。在理解一个基于表达式的程序时，我们可以自底向上地学习程序，从小的表达式开始理解，再理解上级的表达式。如果表达式没有副作用，在学习了这个表达式之后就可以把它看作一个黑盒了。一般来说函数式的语言都会支持更多类型的表达式（如 if 表达式），函数式语言的宗旨之一也是通过组合无副作用的函数而实现更复杂的功能。</p>

<!--
https://fsharpforfunandprofit.com/posts/expressions-vs-statements/
-->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>go.dev 上的观点应该可以算是语言设计者的吧 https://go.dev/doc/faq#Does_Go_have_a_ternary_form <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>weirane</name></author><category term="Programming" /><category term="functional-programming" /><category term="programming-languages" /><summary type="html"><![CDATA[Thoughts on Expression-oriented Programming Languages]]></summary></entry><entry><title type="html">使用 bwrap 隔离 WPS Office</title><link href="https://blog.ruo-chen.wang/2021/08/bwrap-wps.html" rel="alternate" type="text/html" title="使用 bwrap 隔离 WPS Office" /><published>2021-08-20T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2021/08/bwrap-wps</id><content type="html" xml:base="https://blog.ruo-chen.wang/2021/08/bwrap-wps.html"><![CDATA[<p>看到依云在 <a href="https://blog.lilydjwg.me/2021/8/12/using-bwrap.215869.html">博客</a> 中提到了非特权沙盒工具 <a href="https://github.com/containers/bubblewrap">bwrap</a>。博客的结尾提到可以用它来跑一些不太干净的软件，便来配置一下 WPS Office。</p>

<p>WPS 目前（AUR 版本 <code>11.1.0.10702-1</code>）还有使用反斜杠作为文件路径分隔符的问题，不过没有影响到外部的观感，只是在 <code>~/.local/share/Kingsoft</code> 内部。但是它每次运行都会在后台启动 <code>wpscloudsvr</code> 进程，可能和云同步有关吧，每次还要 kill 一下，有点麻烦。另外作为那种不得不使用的商业软件，还是感觉隔离一下舒服一些。</p>

<p>使用的 bwrap 命令修改自依云的博客。<code>wrap-wps</code> 脚本如下：</p>
<pre><code class="language-sh">#!/bin/bash

# 根据扩展名选择对应的 WPS 程序
file=$1
case $file in
    *.doc | *.docx) exe=/usr/bin/wps ;;
    *.xls | *.xlsx) exe=/usr/bin/et ;;
    *.ppt | *.pptx) exe=/usr/bin/wpp ;;
    *) exe=/usr/bin/wps ;;
esac

binds=()
for dir in fontconfig gtk-2.0 gtk-3.0 mimeapps.list Kingsoft; do
    binds+=(--ro-bind ~/.config/"$dir" ~/.config/"$dir")
done

# bind mount 需要操作的文件
if [[ -f "$file" ]]; then
    path="$(realpath "$file")"
    binds+=(--bind "$path" "$path")
fi

exec bwrap --unshare-all --die-with-parent \
    --ro-bind / / \
    --tmpfs /sys --tmpfs /home --tmpfs /tmp --tmpfs /run --proc /proc --dev /dev \
    --ro-bind "$XDG_RUNTIME_DIR" "$XDG_RUNTIME_DIR" \
    --ro-bind /tmp/.X11-unix /tmp/.X11-unix \
    "${binds[@]}" \
    --ro-bind ~/Documents ~/Documents \
    --bind ~/tmp ~/tmp \
    "$exe" "$@"
</code></pre>

<p>可以在使用此脚本之前运行一下 wps，让它生成 <code>~/.config/Kingsoft</code>，避免每次启动还要同意一下许可证。</p>

<p>再写一个 application 文件并配置上文件类型关联。把
<code>/usr/share/applications/wps-office-prometheus.desktop</code> 复制到
<code>~/.local/share/applications/wps-office-wrap.desktop</code>，并把 <code>Exec</code> 的命令改成上面的 <code>wrap-wps</code>，<code>InitialPreference</code> 调成 99，把各个 WPS 程序的 <code>MimeType</code>
合并。如下</p>

<pre><code class="language-diff">diff --git a/usr/share/applications/wps-office-prometheus.desktop b/home/wang/.local/share/applications/wps-office-wrap.desktop
index 820214f..87ab130 100644
--- a/usr/share/applications/wps-office-prometheus.desktop
+++ b/home/wang/.local/share/applications/wps-office-wrap.desktop
@@ -2,7 +2,8 @@
 Comment=Use WPS Writer to office work.
 Comment[zh_CN]=使用 WPS 2019进行办公
-Exec=/usr/bin/wps %F
+Exec=/home/wang/scripts/wrap-wps %U
 GenericName=WPS
 GenericName[zh_CN]=WPS 2019
+MimeType=application/wps-office.et;application/wps-office.ett;application/wps-office.ets;application/wps-office.eto;application/wps-office.xls;application/wps-office.xlt;application/vnd.ms-excel;application/msexcel;application/x-msexcel;application/wps-office.xlsx;application/wps-office.xltx;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;application/wps-office.uos;application/wps-office.dps;application/wps-office.dpt;application/wps-office.dpss;application/wps-office.dpso;application/wps-office.ppt;application/wps-office.pot;application/vnd.ms-powerpoint;application/vnd.mspowerpoint;application/mspowerpoint;application/powerpoint;application/x-mspowerpoint;application/wps-office.pptx;application/wps-office.potx;application/vnd.openxmlformats-officedocument.presentationml.presentation;application/vnd.openxmlformats-officedocument.presentationml.slideshow;application/wps-office.uop;application/wps-office.wps;application/wps-office.wpt;application/wps-office.wpso;application/wps-office.wpss;application/wps-office.doc;application/wps-office.dot;application/vnd.ms-word;application/msword;application/x-msword;application/msword-template;application/wps-office.docx;application/wps-office.dotx;application/rtf;application/vnd.ms-word.document.macroEnabled.12;application/vnd.openxmlformats-officedocument.wordprocessingml.document;x-scheme-handler/ksoqing;x-scheme-handler/ksowps;x-scheme-handler/ksowpp;x-scheme-handler/ksoet;x-scheme-handler/ksowpscloudsvr;x-scheme-handler/ksowebstartupwps;x-scheme-handler/ksowebstartupet;x-scheme-handler/ksowebstartupwpp;application/wps-office.uot;
 Name=WPS 2019
 Name[zh_CN]=WPS 2019
@@ -16,4 +17,4 @@ X-KDE-SubstituteUID=false
 X-KDE-Username=
 Icon=wps-office2019-kprometheus
-InitialPreference=3
+InitialPreference=99
 StartupWMClass=wpsoffice
</code></pre>

<p>然后在 <code>~/.config/mimeapps.list</code> 中配置默认程序</p>
<pre><code class="language-ini">[Default Applications]
application/vnd.openxmlformats-officedocument.wordprocessingml.document=wps-office-wrap.desktop
application/vnd.openxmlformats-officedocument.spreadsheetml.sheet=wps-office-wrap.desktop
application/vnd.openxmlformats-officedocument.presentationml.presentation=wps-office-wrap.desktop
application/vnd.ms-word=wps-office-wrap.desktop
application/vnd.ms-excel=wps-office-wrap.desktop
application/vnd.ms-powerpoint=wps-office-wrap.desktop
</code></pre>

<hr />

<p>PS. 合并 WPS 的 MimeType 可用以下的 zsh 命令（需要 extendedglob 选项）</p>
<pre><code class="language-zsh">grep MimeType /usr/share/applications/wps-office-^pdf* | cut -d'=' -f2 | paste -sd ''
</code></pre>]]></content><author><name>weirane</name></author><category term="Tweaks" /><category term="bwrap" /><category term="wps" /><summary type="html"><![CDATA[Isolate WPS with bwrap]]></summary></entry><entry><title type="html">从零开始的 λ 演算</title><link href="https://blog.ruo-chen.wang/2021/04/lambda-calculus-from-the-ground-up.html" rel="alternate" type="text/html" title="从零开始的 λ 演算" /><published>2021-04-18T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2021/04/lambda-calculus-from-the-ground-up</id><content type="html" xml:base="https://blog.ruo-chen.wang/2021/04/lambda-calculus-from-the-ground-up.html"><![CDATA[<p>这是我在看完 PyCon 2019 演讲「Lambda Calculus from the Ground Up」之后做的一个文字版，原视频在 <a href="https://youtu.be/pkCLMl0e_0k" class="external">https://youtu.be/pkCLMl0e_0k</a>。另见官网中的
<a href="https://pycon-archive.python.org/2019/schedule/presentation/79/">介绍</a>，这里提供一个翻译。</p>

<blockquote>
  <p>最近关于编程风格的指南层出不穷。但是如果我们把风格限制为只允许出现单参数的函数会发生什么呢？没有模组，没有类，没有控制流，没有数据结构，甚至连整数、正则表达式等内建类型都没有，只有函数。用这种风格能写出程序吗？令人惊讶的是，答案是肯定的。在这个教程中，你将学到如何从零开始在 Python 中推导 λ 演算。</p>

  <p>你不会在这个教程中学到有实际用处的东西。没有打包，没有工具，没有库，没有部署，也没有神奇的 Python 编程技术。你也不会学到会被你用在实际项目上的东西。但是你将获得很多乐趣，将感到惊叹，并学习一些基础的计算机科学，这是你进一步探索函数式编程、类型理论、编程语言等话题的起点。</p>
</blockquote>

<h2 id="规则">规则</h2>

<p>如上介绍所说，我们只允许函数调用，或者参数替换这一种操作。以下列举一些不被允许的操作：</p>

<pre><code class="language-python">def f(x):
    return x + 1  # 不允许使用数字和运算符 +

def f(x, y):
    ...  # 只允许单个参数
</code></pre>

<p>以下是一些合法的操作，但是他们好像没什么意义：</p>

<pre><code class="language-python">def f(x):
    return x

def f(x):
    return x(x)

def f(x):
    def g(y):
        return x(y)
    return g
</code></pre>

<p>所以在这样的一个如此抽象的系统中，我们可以做些什么？</p>

<h2 id="布尔值1827">布尔值（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=18m27s">18:27</a>）</h2>

<p>首先来构造布尔值和布尔运算。可以借用选择器的概念来构造布尔值。<code>TRUE</code> 选择两个值中的第一个，而 <code>FALSE</code> 选择第二个。注意这里的 <code>TRUE</code> 和 <code>FALSE</code> 并不是一个具体的值，而是一种行为。</p>

<pre><code class="language-python">def TRUE(x):
    return lambda y: x

def FALSE(x):
    return lambda y: y
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; TRUE('5v')('gnd')
'5v'
&gt;&gt;&gt; FALSE('5v')('gnd')
'gnd'
</code></pre>

<p>接下来是布尔运算 <code>NOT</code>, <code>AND</code> 和 <code>OR</code>。注意到 <code>NOT</code> 的参数应该是 <code>TRUE</code> 或者
<code>FALSE</code>，它们都是需要两个输入的函数（<a href="https://en.wikipedia.org/wiki/Currying">柯里化</a>的）。然后根据 <code>TRUE</code> 和
<code>FALSE</code> 在两个值中的选择情况便可构造出 <code>NOT</code>。</p>

<pre><code class="language-python">def NOT(x):
    return x(FALSE)(TRUE)
</code></pre>

<p>对于 <code>AND</code>，在它的第一个参数为 <code>TRUE</code> 的时候，值就等于第二个参数；在第一个参数为
<code>FALSE</code> 的时候，值为 <code>FALSE</code>（也就是它的第一个参数）。<code>OR</code> 可以根据类似的思想写出：</p>

<pre><code class="language-python">def AND(x):
    return lambda y: x(y)(x)

def OR(x):
    return lambda y: x(x)(y)
</code></pre>

<details>
  <summary>布尔运算演示</summary>
  <pre><code class="language-python-repl">&gt;&gt;&gt; NOT(TRUE)
&lt;function FALSE(x)&gt;
&gt;&gt;&gt; NOT(FALSE)
&lt;function TRUE(x)&gt;
</code></pre>

  <pre><code class="language-python-repl">&gt;&gt;&gt; AND(TRUE)(TRUE)
&lt;function TRUE(x)&gt;
&gt;&gt;&gt; AND(TRUE)(FALSE)
&lt;function FALSE(x)&gt;
&gt;&gt;&gt; AND(FALSE)(TRUE)
&lt;function FALSE(x)&gt;
&gt;&gt;&gt; AND(FALSE)(FALSE)
&lt;function FALSE(x)&gt;
</code></pre>

  <pre><code class="language-python-repl">&gt;&gt;&gt; OR(TRUE)(TRUE)
&lt;function TRUE(x)&gt;
&gt;&gt;&gt; OR(TRUE)(FALSE)
&lt;function TRUE(x)&gt;
&gt;&gt;&gt; OR(FALSE)(TRUE)
&lt;function TRUE(x)&gt;
&gt;&gt;&gt; OR(FALSE)(FALSE)
&lt;function FALSE(x)&gt;
</code></pre>
</details>

<h2 id="数字3445">数字（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=34m45s">34:45</a>）</h2>

<p>因为我们能够做的只有函数调用，所以可以尝试用调用函数的次数表示数字，比如
<code>TWO(f)(x)</code> 的含义是以 <code>x</code> 为初始值，调用 <code>f</code> 两次：</p>
<pre><code class="language-python">ONE = lambda f: lambda x: f(x)
TWO = lambda f: lambda x: f(f(x))
THREE = lambda f: lambda x: f(f(f(x)))
FOUR = lambda f: lambda x: f(f(f(f(x))))
</code></pre>

<p>零表示为调用函数零次，即不调用函数：</p>
<pre><code class="language-python">ZERO = lambda f: lambda x: x
</code></pre>

<p>为了能够方便地展示我们的系统中的数字，在此写一个函数用来将系统中的数字转为
Python 中的一个 <code>int</code>。这个函数并不在 λ 演算系统中，只是为了方便地查看系统中的数字。</p>
<pre><code class="language-python">def toint(n):
    return n(lambda x: x + 1)(0)
</code></pre>

<pre><code class="language-python">&gt;&gt;&gt; toint(THREE)
3
</code></pre>

<h3 id="加法和乘法5002">加法和乘法（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=50m02s">50:02</a>）</h3>

<p>使用 <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano 公理</a> 的思想，先实现一个数字的后继。</p>
<pre><code class="language-python">SUCC = lambda n: lambda f: lambda x: f(n(f)(x))
</code></pre>

<p>在这个实现中，<code>SUCC</code> 的返回值是一个数（因为拥有 <code>lambda f: lambda x: xxx</code> 这样的「接口」），而这个返回的数是以 <code>x</code> 为初始值调用了 <code>n</code> 次函数 <code>f</code>（用 <code>n(f)(x)</code>
表示）后又多调用了 <code>f</code> 一次的结果，所以表示 <em>n</em> + 1。</p>

<pre><code class="language-python-repl">&gt;&gt;&gt; toint(SUCC(THREE))
4
</code></pre>

<p>有了 <code>SUCC</code> 就可以实现加法了。<em>x</em> + <em>y</em> 就是在 <em>x</em> 的基础上调用 <em>y</em> 次
<code>SUCC</code>。而数字的行为正好是调用某个函数多少次。</p>
<pre><code class="language-python">ADD = lambda x: lambda y: y(SUCC)(x)
</code></pre>

<p>乘法就是将「调用函数 <code>f</code> <em>x</em> 次」（即 <code>x(f)</code> 这个行为）重复 <em>y</em> 次：</p>
<pre><code class="language-python">MUL = lambda x: lambda y: lambda f: y(x(f))
</code></pre>

<p>从上面的定义可以看出乘法就是用<a href="https://en.wikipedia.org/wiki/Function_composition">函数的复合</a>，即 <code>MUL x y = y ∘ x</code>。</p>

<p>加法和乘法的演示：</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; toint(ADD(FOUR)(THREE))
7
&gt;&gt;&gt; toint(MUL(FOUR)(THREE))
12
</code></pre>

<h3 id="二元组20349">二元组（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=2h03m49s">2:03:49</a>）</h3>

<p>为了实现减法，我们需要先实现二元组。</p>

<p><code>CONS(a)(b)</code> 将会返回一个「选择器」，这个选择器根据给它的参数选择 <code>a</code> 和 <code>b</code> 中的一个。这里的函数名借用了 Lisp 中的名字。</p>
<pre><code class="language-python">CONS = lambda a: lambda b: (lambda s: s(a)(b))
CAR = lambda p: p(TRUE)
CDR = lambda p: p(FALSE)
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; p = CONS(2)(3)
&gt;&gt;&gt; CAR(p)
2
&gt;&gt;&gt; CDR(p)
3
</code></pre>

<p>这里的 <code>CONS</code> 接受两个参数并构造了一个二元组，<code>CAR</code> 和 <code>CDR</code> 分别取二元组中的第一个和第二个值。</p>

<h3 id="减法21215">减法（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=2h12m15s">2:12:15</a>）</h3>

<p>下面借助二元组来实现一个数的前驱。我们可以从 (0, 0) 开始增加，(1, 0), (2, 1) ……
二元组的第二个数是第一个数的前驱，而第一个数就是增加的次数。</p>

<pre><code class="language-python">T = lambda p: CONS(SUCC(CAR(p)))(CAR(p))
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; a = FOUR(T)(CONS(ZERO)(ZERO))
&gt;&gt;&gt; toint(CAR(a))
4
&gt;&gt;&gt; toint(CDR(a))
3
</code></pre>

<p>上面的 <code>a</code> 是从 (0, 0) 开始执行了函数 <code>T</code> 4 次后的结果，它本身是一个二元组，第二个值就是 4 的前驱 3。于是实现前驱的方式为从 <code>CONS(ZERO)(ZERO)</code> 开始执行函数
<code>T</code> <code>n</code> 次，再取二元组的第二个值：</p>
<pre><code class="language-python">PRED = lambda n: CDR(n(T)(CONS(ZERO)(ZERO)))
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; a = FOUR(THREE)
&gt;&gt;&gt; toint(a)
81
&gt;&gt;&gt; b = PRED(a)
&gt;&gt;&gt; toint(b)
80
</code></pre>

<p>然后仿造加法构造减法：</p>
<pre><code class="language-python">SUB = lambda x: lambda y: y(PRED)(x)
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; a = SUB(FOUR)(TWO)
&gt;&gt;&gt; toint(a)
2
</code></pre>

<h3 id="判断一个数是否为零22412">判断一个数是否为零（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=2h24m12s">2:24:12</a>）</h3>

<p>由于 <code>ZERO</code> 的行为是直接返回第二个输入，所以下面的第二个括号中为 <code>TRUE</code>。而其它的数都会调用第一个输入，所以直接让这个输入返回 <code>FALSE</code>。</p>
<pre><code class="language-python">ISZERO = lambda n: n(lambda _: FALSE)(TRUE)
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; ISZERO(ZERO)
&lt;function TRUE(x)&gt;
&gt;&gt;&gt; ISZERO(ONE)
&lt;function FALSE(x)&gt;
</code></pre>

<h2 id="递归23013">递归（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=2h30m13s">2:30:13</a>）</h2>

<p>我们已经有了 <code>AND</code>, <code>SUCC</code>, <code>ADD</code>, <code>CONS</code>, <code>CAR</code> 和 <code>ISZERO</code> 等等函数，现在我们要来挑战写出阶乘函数。阶乘在普通 Python 中的一种写法是</p>
<pre><code class="language-python">fact = lambda n: 1 if n == 0 else n * fact(n-1)
</code></pre>

<p>它只用了判断是否为零，乘法和减法三种操作。把它转化为 λ 演算中的形式，得到</p>
<pre><code class="language-python">FACT = lambda n: ISZERO(n) \
                 (ONE) \
                 (MUL(n)(FACT(PRED(n))))
</code></pre>

<p>但是这个实现有问题：</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; FACT(THREE)
RecursionError: maximum recursion depth exceeded
</code></pre>

<h3 id="惰性求值23440">惰性求值（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=2h34m40s">2:34:40</a>）</h3>

<p>原因是 Python 函数不是惰性求值（lazy）的，递归发生在 <code>ISZERO</code> 判断之前。为了规避这个限制，我们实现以下的 lazy 版本</p>
<pre><code class="language-python">L_TRUE = lambda x: lambda y: x()
L_FALSE = lambda x: lambda y: y()
L_ISZERO = lambda n: n(lambda _: L_FALSE)(L_TRUE)

FACT = lambda n: L_ISZERO(n) \
                 (lambda: ONE) \
                 (lambda: MUL(n)(FACT(PRED(n))))
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; a = FACT(THREE)
&gt;&gt;&gt; toint(a)
6
</code></pre>

<h3 id="避免引用自己24730">避免引用自己（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=2h47m30s">2:47:30</a>）</h3>

<p>目前还有一个问题，在 λ 演算中没有全局变量，没有把值「存储」在一个变量中的概念。而我们在 <code>FACT</code> 的定义中使用了 <code>FACT</code> 这个名字。</p>

<div class="notice--info">
  <p><i class="fas fa-question-circle"></i>
<strong>我们也用了 <code>ISZERO</code> 和 <code>ONE</code> 等等名字啊？</strong></p>

  <p>事实上这些名字不需要存储的概念。可以把所有出现了 <code>ONE</code> 的地方换成它的定义（相当于 <code>:%s/\&lt;ONE\&gt;/(lambda f:lambda x:f(x))/g</code>）而程序还是会正确运行。而不能换
<code>FACT</code> 的原因是它的定义本身就使用了 <code>FACT</code> 这个名字。</p>
</div>

<p>如何在实现 <code>FACT</code> 的时候不引用它自己的名字？为了方便先用 <code>fact</code> 函数来试验，我们不希望在下面的实现中出现 <code>fact</code>：</p>
<pre><code class="language-python">fact = lambda n: 1 if n == 0 else n * fact(n-1)
#                                     ^^^^ bad
</code></pre>

<p>一种方式是把 <code>fact</code> 作为参数传进去，但是这样还是用了 <code>fact</code> 这个名字，而且这个写法在 <code>fact</code> 还没定义的时候就使用了它。</p>
<pre><code class="language-python">fact = (lambda f: lambda n: 1 if n == 0 else n * f(n-1)) \
       (fact)
#       ^^^^ ?
</code></pre>

<p>解决方案是直接复制粘贴，而不是把自己的名字传进参数：</p>
<pre><code class="language-python">fact = (lambda f: lambda n: 1 if n == 0 else n * f(n-1)) \
       (lambda f: lambda n: 1 if n == 0 else n * f(n-1))
</code></pre>

<p>我们还需要修正一下 <code>f</code> 的调用方法（因为需要先传入 <code>f</code> 再传入 <code>n</code>）。下面是最终的结果：</p>
<pre><code class="language-python">fact = (lambda f: lambda n: 1 if n == 0 else n * f(f)(n-1)) \
       (lambda f: lambda n: 1 if n == 0 else n * f(f)(n-1))
#                                                ^^^^
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; fact(4)
24
</code></pre>

<p>可以把 <code>fact</code> 直接换成它的定义：</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (lambda f: lambda n: 1 if n == 0 else n * f(f)(n-1)) \
... (lambda f: lambda n: 1 if n == 0 else n * f(f)(n-1))(4)
24
</code></pre>

<h3 id="不动点30038">不动点（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=3h00m38s">3:00:38</a>）</h3>

<p>以上的实现有一点不好，它把一个很长的括号重复了两次。我们也可以借助不动点实现
<code>fact</code>。</p>

<p>回到之前尝试实现 <code>fact</code> 的时候，</p>
<pre><code class="language-python">fact = (lambda f: lambda n: 1 if n == 0 else n * f(n-1))(fact)
</code></pre>

<p>如果把中间的部分抽出来</p>
<pre><code class="language-python">R = lambda f: lambda n: 1 if n == 0 else n * f(n-1)
</code></pre>

<p>那么 <code>fact = R(fact)</code>，即 <code>fact</code> 是 <code>R</code> 的一个不动点。如果有一个可以计算不动点的函数，就可以得到 <code>fact</code> 了。</p>

<p>假设这个函数存在，设它为 <code>Y</code>。那么有 <code>Y(R) = R(Y(R))</code>。变形：</p>
<pre><code class="language-python">Y(R) = (lambda x: R(x))(Y(R))
</code></pre>
<p>仿照上一节中的做法，把括号中的表达式复制一遍，再修正一下 <code>x</code> 的调用方法：</p>
<pre><code class="language-python">Y(R) = (lambda x: R(x))(lambda x: R(x))
</code></pre>

<pre><code class="language-python">Y(R) = (lambda x: R(x(x)))(lambda x: R(x(x)))
</code></pre>

<p>那么我们就得到了 <code>Y</code></p>
<pre><code class="language-python">Y = lambda f: (lambda x: f(x(x)))(lambda x: f(x(x)))
</code></pre>

<h3 id="y-组合子31320">Y 组合子（<a href="https://www.youtube.com/watch?v=pkCLMl0e_0k&amp;t=3h13m20s">3:13:20</a>）</h3>

<p>这里的 <code>Y</code> 就是著名的 <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus">Y 组合子</a>（Y combinator）。但是</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; R = lambda f: lambda n: 1 if n == 0 else n * f(n-1)
&gt;&gt;&gt; fact = Y(R)
RecursionError: maximum recursion depth exceeded
</code></pre>

<p>要解决这个问题，可以把 <code>x(x)</code> 换成 <code>lambda z: x(x)(z)</code>，它可以延后 <code>x</code> 的求值。</p>
<pre><code class="language-python">Y = lambda f: (lambda x: f(lambda z: x(x)(z)))(lambda x: f(lambda z: x(x)(z)))
</code></pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; R = lambda f: lambda n: 1 if n == 0 else n * f(n-1)
&gt;&gt;&gt; fact = Y(R)
&gt;&gt;&gt; fact(4)
24
</code></pre>

<p>把 <code>Y</code> 用在其它函数上：</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fib = Y(lambda f: lambda n: 1 if n &lt;= 2 else f(n-1) + f(n-2))
&gt;&gt;&gt; fib(10)
55
</code></pre>

<p>实现 <code>FACT</code>：</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; FACT = Y(
...     lambda f: lambda n: L_ISZERO(n) \
...                         (lambda: ONE) \
...                         (lambda: MUL(n)(f(PRED(n))))
... )
&gt;&gt;&gt; a = FACT(FOUR)
&gt;&gt;&gt; toint(a)
24
</code></pre>

<p>本文中的代码已整理到 <a href="https://gist.github.com/weirane/62a976baab7f4e56a4b5de596d41177e">Gist</a> 上。</p>

<h2 id="补充">补充</h2>

<p><a href="#惰性求值23440">惰性求值</a> 一节中也可以使用另一种方法。参考 <a href="#y-组合子31320">Y 组合子</a>
一节，用 <code>lambda x: f(x)</code> 代替 <code>f</code>，这样不需要新定义 lazy 版本的函数。因为万物皆是函数，所以不需要担心 <code>f(x)</code> 因为 <code>f</code> 不是函数而出错。</p>

<pre><code class="language-python">FACT = lambda n: ISZERO(n) \
                 (lambda x: ONE(x)) \
                 (lambda x: MUL(n)(FACT(PRED(n)))(x))
</code></pre>
<pre><code class="language-python">FACT = Y(
    lambda f: lambda n: ISZERO(n) \
                        (lambda x: ONE(x)) \
                        (lambda x: MUL(n)(f(PRED(n)))(x))
)
</code></pre>

<h2 id="总结">总结</h2>

<ul>
  <li>这里推导的 λ 演算没有什么实际用途，没有谁会用这里的 λ 演算写一个现实中使用的程
  序；</li>
  <li>但是 λ 演算的思想在函数式语言中随处可见，非函数式语言也都在慢慢吸收函数式语言
  中的一些的思想和概念；</li>
  <li>λ 演算就像机器语言一样。现在绝大多数人都在写高级语言，但是高级语言在某种程度上
  是机器语言的抽象，了解一些机器语言或者汇编的知识有助于写出更好，效率更高的代
  码。类似地，了解 λ 演算对理解和运用函数式语言和其它语言中的函数式元素是很有
  益的。</li>
</ul>]]></content><author><name>weirane</name></author><category term="Programming" /><category term="functional-programming" /><category term="lambda-calculus" /><category term="python" /><summary type="html"><![CDATA[A summary of the PyCon talk "Lambda Calculus from the Ground Up"]]></summary></entry><entry><title type="html">从 Manjaro 迁移到 Arch Linux</title><link href="https://blog.ruo-chen.wang/2021/03/switch-from-manjaro-to-arch.html" rel="alternate" type="text/html" title="从 Manjaro 迁移到 Arch Linux" /><published>2021-03-21T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2021/03/switch-from-manjaro-to-arch</id><content type="html" xml:base="https://blog.ruo-chen.wang/2021/03/switch-from-manjaro-to-arch.html"><![CDATA[<p>今天我把系统换成了 Arch Linux，用的是 Btrfs 文件系统，套上 LUKS 加密（加密包括
<code>/boot</code>）。由于我已经在虚拟机里面实验过整个过程，所以今天的安装过程非常顺利，一共只用了一两个小时。</p>

<ul>
  <li>2021-03-25 更新：增加了 <a href="#redshift-无法使用-geoclue">redshift 无法使用 geoclue</a> 一节</li>
  <li>2021-04-18 更新：增加了 <a href="#将-cache-单独分为一个子卷">将 <code>~/.cache</code> 单独分为一个子卷</a> 一节</li>
</ul>

<h2 id="背景">背景</h2>

<p>前几天用 <code>btrfs-convert</code> 把我的 Manjaro 的文件系统换成了 Btrfs，然后继续开发我的
Btrfs 快照管理工具 <a href="https://github.com/weirane/dosnap">dosnap</a>。奇怪的是，在出错的时候（如 <code>panic!</code>）程序不会退出
，而是直接卡住。这还不是最致命的，过了几秒钟我发现我的 polybar 不见了，然后发现我的家目录里少了一些东西，包括 <code>~/.config</code>。还好我之前有做快照，可以直接用
<code>rsync</code> 恢复数据。但是在我的一个 Arch Linux 虚拟机中程序如果出错会正确退出。不知道是为什么，可能是 <code>btrfs-convert</code> 的什么 bug。然后就想到用 Arch 虚拟机也有很长时间了，于是打算直接把物理机也换到 Arch Linux 上来。</p>

<h2 id="备份">备份</h2>

<p>可以使用 Btrfs 的 send/receive 功能进行备份。注意备份的移动硬盘也需要是 Btrfs 文件系统。先对各个子卷做只读快照，然后对每个快照进行 <code>btrfs send</code>：</p>

<pre><code class="language-sh">sudo btrfs send /mnt/_snapshots/${SNAPSHOT_NAME?} | sudo btrfs receive ${EXTERNAL_DRIVE?}
</code></pre>

<p>然后再记录一下安装过的软件：</p>
<pre><code class="language-sh">pacman -Qe &gt;${EXTERNAL_DRIVE?}/pacman-qe
</code></pre>

<h2 id="安装">安装</h2>

<p>启动 archiso，然后调整一下终端字体</p>
<pre><code class="language-sh">setfont ter-v28b
</code></pre>

<h3 id="installation-guide">Installation Guide</h3>

<p>打开 <a href="https://wiki.archlinux.org/index.php/installation_guide">installation guide</a>，一直做到 Partition the disks 之前。</p>

<p>由于磁盘已经分区，所以不需要再分区了。直接上 LUKS 并格式化为 Btrfs。注意需要用
luks1，因为 GRUB 目前还不支持 LUKS2。</p>
<pre><code class="language-sh">cryptsetup --type luks1 luksFormat /dev/nvme0n1p4
cryptsetup open /dev/nvme0n1p4 archlinux
mkfs.btrfs -L archlinux /dev/mapper/archlinux
</code></pre>

<p>然后创建子卷并挂载分区</p>
<pre><code class="language-sh">mount /dev/mapper/archlinux /mnt
btrfs subv create /mnt/@
btrfs subv create /mnt/@home
btrfs subv create /mnt/@opt
btrfs subv create /mnt/@var
umount /mnt

opt='noatime,ssd,space_cache=v2,compress=zstd'
mount -o $opt,subvol=@ /dev/mapper/archlinux /mnt
mkdir /mnt/{efi,var,home,opt}
mount /dev/nvme0n1p1 /mnt/efi
mount -o $opt,subvol=@home /dev/mapper/archlinux /mnt/home
mount -o $opt,subvol=@opt /dev/mapper/archlinux /mnt/opt
mount -o $opt,subvol=@var /dev/mapper/archlinux /mnt/var
</code></pre>

<p>对 <code>/var/log/journal</code> 禁用 CoW：</p>
<pre><code class="language-sh">mkdir -p /mnt/var/log/journal
chattr +C /mnt/var/log/journal
</code></pre>

<p>然后从 installation guide 的 <a href="https://wiki.archlinux.org/index.php/installation_guide#Installation">Installation</a> 一节开始继续一直做到结尾，记得要在 <code>pacstrap</code> 的时候加上 <code>btrfs-progs</code>。</p>

<h3 id="额外的操作">额外的操作</h3>

<p>安装到这里还需一些额外的操作。更改 <code>/etc/mkinitcpio.conf</code> 的 <code>BINARIES</code>，然后在
<code>HOOKS</code> 中的 <code>filesystems</code> 之前加入 <code>encrypt</code>：</p>
<pre><code class="language-bash">BINARIES=(/usr/bin/btrfs)
HOOKS=(base udev autodetect modconf block encrypt filesystems keyboard fsck)
</code></pre>
<p>然后重新生成 initramfs</p>
<pre><code class="language-sh">mkinitcpio -P
</code></pre>

<p>更改 <code>/etc/default/grub</code> 中的内核命令行，这里我还顺便打开了 cgroup v2。
<code>PARTUUID</code> 可以使用 <code>blkid</code> 命令查看。</p>
<pre><code class="language-sh">GRUB_CMDLINE_LINUX_DEFAULT="loglevel=3 quiet systemd.unified_cgroup_hierarchy=1"
GRUB_CMDLINE_LINUX="cryptdevice=PARTUUID=xxx:archlinux"
</code></pre>

<h3 id="同步家目录">同步家目录</h3>

<p>新建用户，并从备份中用 rsync 把家目录同步回来：</p>
<pre><code class="language-sh"># run as wang
rsync -a ${EXTERNAL_DRIVE?}/home-snap/wang/* ~
rsync -a ${EXTERNAL_DRIVE?}/home-snap/wang/.* ~
</code></pre>

<h3 id="安装软件包">安装软件包</h3>

<p>安装我自己常用的软件</p>
<pre><code class="language-sh">cd ~/.dotfiles/weirane-dotfiles-deps
makepkg -si
</code></pre>

<p>用下面的命令查看有哪些之前安装过而不在本机上的包，然后选择要安装的包并安装。</p>
<pre><code class="language-sh">comm -23 &lt;(cut -d' ' -f1 ${EXTERNAL_DRIVE?}/pacman-qe | sort) \
         &lt;(pacman -Qq | sort) | less
</code></pre>

<h2 id="配置">配置</h2>

<p>下面进行一些增加安全性或者便携性的配置。</p>

<h3 id="加密-swap">加密 swap</h3>

<p>为防止关机后 swap 中残留明文的内存数据，需要将 swap 加密。我不需要 hibernation，所以参考 <a href="https://wiki.archlinux.org/index.php/Dm-crypt/Swap_encryption#Without_suspend-to-disk_support">ArchWiki</a>，将以下内容加入 <code>/etc/crypttab</code>：</p>
<pre><code>swap  PARTUUID=xxx  /dev/urandom  swap,cipher=aes-xts-plain64,size=512
</code></pre>

<p>将原来 <code>/etc/fstab</code> 中 swap 的一行改为</p>
<pre><code>/dev/mapper/swap        none            swap            defaults        0 0
</code></pre>

<h3 id="key-in-initramfs">Key in initramfs</h3>

<p>可以在 initramfs 中放一个 LUKS key，这样在开机的时候就不需要输两次 LUKS 密码了。我一般将 key 放在 <code>/etc</code> 中。注意要调整 key file 和装有 key file 的 initramfs 的权限。</p>

<pre><code class="language-sh">sudo dd bs=512 count=4 if=/dev/urandom of=/path/to/key
sudo cryptsetup luksAddKey /dev/nvme0n1p4 /path/to/key
chmod 000 /path/to/key
chmod -R g-rwx,o-rwx /boot
</code></pre>

<p>把 key 加入 <code>/etc/mkinitcpio.conf</code> 中的 <code>FILES</code>：</p>
<pre><code class="language-bash">FILES=(/path/to/key)
</code></pre>

<p>改 <code>/etc/default/grub</code> 中的内核命令行，加入 <code>cryptkey=rootfs:/path/to/key</code>：</p>
<pre><code class="language-sh">GRUB_CMDLINE_LINUX="cryptdevice=PARTUUID=xxx:archlinux cryptkey=rootfs:/path/to/key"
</code></pre>

<p>最后重新生成 initramfs 和 GRUB config</p>
<pre><code class="language-sh">sudo mkinitcpio -P
sudo grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>

<h2 id="解决问题">解决问题</h2>

<h3 id="xbacklight">xbacklight</h3>

<p>进入图形界面后发现 polybar 中的亮度模块没有显示，<code>xbacklight</code> 命令没有输出。参考
<a href="https://wiki.archlinux.org/index.php/Backlight#xbacklight">ArchWiki</a> 之后发现应该安装 <code>xf86-video-intel</code> 并将下面的配置写入
<code>/etc/X11/xorg.conf.d/20-xbacklight.conf</code>：</p>
<pre><code>Section "Device"
    Identifier  "Intel Graphics"
    Driver      "intel"
    Option      "Backlight"  "intel_backlight"
EndSection
</code></pre>

<h3 id="redshift-无法使用-geoclue">redshift 无法使用 geoclue</h3>

<p>运行 <code>redshift</code> 有如下报错</p>
<pre><code>Trying location provider `geoclue2'...
Using provider `geoclue2'.
Using method `randr'.
Waiting for initial location to become available...
Unable to start GeoClue client: GDBus.Error:org.freedesktop.DBus.Error.AccessDenied: 'redshift' disallowed, no agent for UID 1000.
Access to the current location was denied by GeoClue!
Make sure that location services are enabled and that Redshift is permitted
to use location services. See https://github.com/jonls/redshift#faq for more
information.
Unable to get location from provider.
</code></pre>

<p>查阅 <a href="https://wiki.archlinux.org/index.php/Redshift#Redshift_GDBus.Error:org.freedesktop.DBus.Error.AccessDenied_on_start">ArchWiki</a>，将以下内容写入
<code>~/.config/systemd/user/geoclue-agent.service</code></p>

<pre><code class="language-ini">[Unit]
Description=redshift needs to get a (geo)clue

[Service]
ExecStart=/usr/lib/geoclue-2.0/demos/agent

[Install]
WantedBy=default.target
</code></pre>

<p>运行命令 <code>systemctl --user enable --now geoclue-agent.service</code> 之后就可以使用
redshift 了。</p>

<h3 id="将-cache-单独分为一个子卷">将 <code>~/.cache</code> 单独分为一个子卷</h3>

<p>我现在对我的家目录每两小时进行<a href="https://github.com/weirane/dosnap">快照</a>，用了一段时间后<a href="https://github.com/nachoparker/btrfs-du">发现</a>每个快照都有至少 30 MB 的 exclusive data。<a href="https://serverfault.com/a/580264">比较</a>后发现主要是 <code>~/.cache</code>
中的数据，所以想把它单独分为一个子卷。</p>

<p>登出当前用户，并在 tty 登陆 root 用户。把 <code>~/.cache</code> 这个目录空出来，并创建子卷</p>
<pre><code class="language-sh">cd /home/wang
mv .cache .cache2
btrfs subv create /home/wang/.cache
</code></pre>

<p>然后把数据复制回来，再恢复权限。</p>
<pre><code class="language-sh">cp -a --reflink .cache2/* .cache
chown wang:wang .cache
rm -r .cache2
</code></pre>

<p>分开 <code>~/.cache</code> 之后每两小时快照的 exclusive data 基本上在 20 MB 之下，效果还可以。</p>

<h2 id="总结">总结</h2>

<p>整个过程挺顺利的，现在应该只剩一些之前在 <code>/etc</code> 中的配置没来得及同步了。由于家目录是直接 <code>rsync</code> 过来的，所以所有的数据都还在，家目录中的程序的配置也没有丢失，
firefox 等程序也不需要重新登录或者进行其它的配置。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://blog.lilydjwg.me/2019/3/31/move-system-to-ssd.214336.html">https://blog.lilydjwg.me/2019/3/31/move-system-to-ssd.214336.html</a></li>
  <li><a href="https://gist.github.com/ansulev/7cdf38a3d387599adf9addd248b09db8">https://gist.github.com/ansulev/7cdf38a3d387599adf9addd248b09db8</a></li>
</ul>]]></content><author><name>weirane</name></author><category term="Tweaks" /><category term="archlinux" /><category term="btrfs" /><category term="luks" /><category term="redshift" /><category term="swap" /><category term="xbacklight" /><summary type="html"><![CDATA[Switch from Manjaro to Arch Linux with LUKS and Btrfs]]></summary></entry><entry><title type="html">使用 pass 管理密码</title><link href="https://blog.ruo-chen.wang/2021/01/pass.html" rel="alternate" type="text/html" title="使用 pass 管理密码" /><published>2021-01-09T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2021/01/pass</id><content type="html" xml:base="https://blog.ruo-chen.wang/2021/01/pass.html"><![CDATA[<p>Pass 是一个使用 GPG 管理密码的工具。它的 <a href="https://www.passwordstore.org/">网站</a> 介绍说：</p>
<blockquote>
  <p>Pass: the standard unix password manager</p>
</blockquote>

<p><del>有 ed 编辑器内味了</del><sup id="fnref:ed-joke"><a href="#fn:ed-joke" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></p>

<p>Pass 保存的密码被存放在目录 <code>${PASSWORD_<wbr />STORE_<wbr />DIR:-<wbr />$HOME/<wbr />.password-store}</code>
下，每个密码都是一个 GPG 加密的文件。除了密码还可以在此文件中存放用户名，<a href="https://en.wikipedia.org/wiki/One-time_password">OTP</a>
URI 等其它信息。同时还可以把该目录作为一个 Git 仓库用于同步密码。</p>

<h2 id="生成-gpg-密钥">生成 GPG 密钥</h2>

<p>如果没有 GPG 密钥对则需要先生成。使用命令</p>
<pre><code class="language-sh">gpg --full-gen-key
</code></pre>
<p>输入对应的信息即可，一般都可以用默认值。关于生成 GPG 密钥还可以看看
<a href="https://wiki.archlinux.org/index.php/GnuPG#Create_a_key_pair">ArchWiki</a>。为了避免每次需要密码的时候都得输入 GPG 密钥的密码，可以配置 <a href="https://wiki.archlinux.org/index.php/GNOME/Keyring">GNOME Keyring</a> 或者 <a href="https://github.com/cruegge/pam-gnupg">pam-gnupg</a> 来在登录后记住密码。</p>

<h2 id="pass-命令"><code>pass</code> 命令</h2>

<p>首先用生成 GPG 密钥的 email 初始化 pass：</p>

<pre><code class="language-sh">pass init ${GPGEMAIL?}
</code></pre>

<h3 id="添加密码">添加密码</h3>

<p>使用命令 <code>pass insert email/fastmail</code>，输入两遍密码即可添加 <code>email/fastmail</code> 的密码。当密码的名字带有 <code>/</code> 时会将密码文件存放在对应的子目录下。运行 <code>pass</code> 或者
<code>pass ls</code> 可以看到目前存储了哪些密码：</p>

<pre><code class="language-console">$ pass ls
Password Store
└── email
    └── fastmail
</code></pre>

<h3 id="生成密码">生成密码</h3>

<p>使用 <code>pass generate website 16</code> 来生成一个长度为 16 的密码并保存为 <code>website</code>。可以加上 <code>-n</code> 选项生成不带特殊符号的密码。</p>

<pre><code class="language-console">$ pass generate website 16 -n
The generated password for website is:
yKGhEkei98fGRKY6
</code></pre>

<h3 id="获取密码">获取密码</h3>

<p>获取 <code>email/fastmail</code> 的密码的方法是运行 <code>pass email/fastmail</code>，或者加上 <code>-c</code> 选项将密码复制到剪贴板，此密码会在 45 秒后从剪贴板消失。注意如果密码文件有多行（如还存放了用户名等其它信息时），此命令只复制第一行。</p>

<h3 id="操作密码文件">操作密码文件</h3>

<p>用 <code>pass mv</code>，<code>pass cp</code>，<code>pass rm</code>，<code>pass edit</code> 对密码文件进行相应的操作。</p>

<h2 id="使用-git">使用 Git</h2>

<p>可以使用 git 来同步密码。在对应的 <code>git</code> 命令前添加 <code>pass</code> 即可直接操作 pass 的
git 仓库。如</p>

<pre><code class="language-sh">pass git init
pass git remote add origin git@git.example.com:password-store.git
pass git push -u origin master
</code></pre>

<p>为了安全还可以配置一个自己的 Git 服务器，见 <a href="/2020/08/git-server.html">搭建一个 Git 服务器</a>。</p>

<h3 id="清除-dangling-commits">清除 dangling commits</h3>

<p>有时想要重写 commit 历史，但是旧 commit 并不会被清除：</p>

<pre><code class="language-console">$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (26/26), done.
dangling commit b876e31a2740da9198c851532ce9a83ccaa71d21
dangling commit 74e9cfda669d39ef8154270fcc8e14e8247b7c05
</code></pre>

<p>此时可以使用如下命令来清除这些 commit。</p>

<pre><code class="language-sh">git reflog expire --expire=now --all
git gc --prune=now
</code></pre>

<h2 id="使用场景">使用场景</h2>

<p>我使用 pass 的主要场景是在脚本中获取密码，或者用于在配置文件中使用 pass 命令获取密码。这样做可以防止直接在配置中明文填写密码。如在 <a href="https://neomutt.org/">neomutt</a> 中配置帐号时：</p>

<pre><code>set my_pass = "`pass show email/foo | head -1`"
set smtp_pass = $my_pass
</code></pre>

<p>Pass 还可在浏览器中使用（Firefox 扩展 <a href="https://github.com/passff/passff">passff</a>，Chrome 扩展 <a href="https://github.com/browserpass/browserpass-extension">browserpass</a>）</p>

<h2 id="pass-的扩展">Pass 的扩展</h2>

<p>Pass 有许多扩展以增强其功能。例如可以通过 <a href="https://github.com/tadfisher/pass-otp">pass-otp</a> 来使用 OTP：</p>

<ul>
  <li>添加 OTP URI: <code>pass otp add email/fastmail</code></li>
  <li>获取 OTP code: <code>pass otp email/fastmail</code></li>
</ul>

<p>虽然密码文件会被 GPG 加密，但是密码库的目录结构和文件名都是不加密的，任何人都可以查看。可以使用 <a href="https://github.com/roddhjav/pass-tomb">pass-tomb</a> 解决这个问题。它将密码存放在一个 <a href="https://www.dyne.org/software/tomb/">tomb</a> 中，查看密码前需要使用 <code>pass open</code> 将 tomb 打开，查看完毕后再使用 <code>pass close</code> 关闭
tomb。</p>

<p>其它的扩展见官网的 <a href="https://www.passwordstore.org/#extensions">列表</a>。</p>

<h2 id="ios">iOS</h2>

<p>Pass 在其它平台上都有客户端，在 iOS 中有 <a href="https://mssun.github.io/passforios/">passforios</a>。它有一些扩展功能，比如可在密码文件的第一行之后使用 <code>key: value</code> 的形式存放其他信息，如用户名等，可以方便地查看和复制这些额外信息。它也可以添加 OTP URI 以获取 OTP code。</p>

<hr />
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:ed-joke">
      <p><a href="https://www.gnu.org/fun/jokes/ed-msg.html" target="_blank">https://www.gnu.org/fun/jokes/ed-msg.html</a> <a href="#fnref:ed-joke" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>weirane</name></author><category term="Tools" /><category term="pass" /><category term="gpg" /><category term="git" /><summary type="html"><![CDATA[Managing passwords with pass]]></summary></entry><entry><title type="html">更换域名</title><link href="https://blog.ruo-chen.wang/2020/09/change-domain.html" rel="alternate" type="text/html" title="更换域名" /><published>2020-09-11T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2020/09/change-domain</id><content type="html" xml:base="https://blog.ruo-chen.wang/2020/09/change-domain.html"><![CDATA[<p>2021-04-18 更新：isso 和 goatcounter 不想写博客了 😂 不过我把配置过程放在<a href="https://wiki.ruo-chen.wang">我的
wiki</a> 上了 → <a href="https://wiki.ruo-chen.wang/wiki/Isso">isso</a>, <a href="https://wiki.ruo-chen.wang/wiki/GoatCounter">goatcounter</a></p>

<hr />

<p>买了一个新域名 <code>ruo-chen.wang</code>，打算用来替换原来的 <code>wangrc.top</code>。顺便把博客的域名从 GitHub 的 <code>weirane.<wbr />github.<wbr />io</code> 换成自己的域名，再把自己搭建的评论系统 <a href="https://posativ.org/isso/">isso</a> 和流量分析工具 <a href="https://www.goatcounter.com/">goatcounter</a> 的 URL 换过来（过些时候感觉可以写写 isso 和 goatcounter 这两个工具）。以后我应该就会一直用
<code>ruo-chen.<wbr />wang</code> 这个域名了，感觉还可以去弄一个域名邮箱。</p>

<p>（挖坑 × 2）</p>]]></content><author><name>weirane</name></author><category term="Miscellaneous" /><summary type="html"><![CDATA[changed domain]]></summary></entry><entry><title type="html">搭建一个 Git 服务器</title><link href="https://blog.ruo-chen.wang/2020/08/git-server.html" rel="alternate" type="text/html" title="搭建一个 Git 服务器" /><published>2020-08-03T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2020/08/git-server</id><content type="html" xml:base="https://blog.ruo-chen.wang/2020/08/git-server.html"><![CDATA[<p>本篇将记录我使用 <a href="https://git-scm.com/book/en/v2/Git-on-the-Server-GitWeb">gitweb</a> 和 <a href="https://nginx.org/">nginx</a> 搭建带有网页界面和 HTTP clone 的 Git 服务器的过程。</p>

<h2 id="git-服务器">Git 服务器</h2>

<p>首先设置能使用 SSH 访问的 Git 服务器，参考 <a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server">Pro Git</a> 中的说明。先在服务器上添加 <code>git</code> 用户</p>

<pre><code class="language-sh">sudo useradd -m /srv/git git
sudo passwd git
</code></pre>

<p>然后导入本地的 SSH key（需要在 <code>/etc/ssh/sshd_config</code> 中设置
<code>Password<wbr />Authenti<wbr />cation yes</code>）</p>

<pre><code class="language-sh">ssh-copy-id -i ~/.ssh/id_rsa git@&lt;IP address&gt;
</code></pre>

<p>为了安全禁用 shell 登录</p>

<pre><code class="language-sh">sudo chsh git -s $(which git-shell)
</code></pre>

<h2 id="gitweb">GitWeb</h2>

<p>Ubuntu 中的 <code>git</code> 包已经包含了 gitweb 需要的一些静态文件，在 <code>/usr/<wbr />share/<wbr />gitweb</code>
里面。还需安装的是 <code>highlight</code> 和 <code>fcgiwrap</code>。</p>

<pre><code class="language-sh">sudo apt install highlight fcgiwrap
</code></pre>

<p>在 <code>/etc/gitweb.conf</code> 中设置 gitweb，其它配置选项可在 <a href="https://git-scm.com/docs/gitweb.conf" title="gitweb.conf(5)"><code>man gitweb.conf</code></a>
中查看。</p>

<pre><code class="language-perl"># path to git projects (&lt;project&gt;.git)
$projectroot = "/srv/git";

# directory to use for temp files
$git_temp = "/tmp";

# html text to include at home page
$home_text = "/srv/git/indextext.html";

# stylesheet to use
#@stylesheets = ("static/gitweb.css");

# javascript code for gitweb
#$javascript = "static/gitweb.js";

# logo to use
#$logo = "static/git-logo.png";

# the 'favicon'
#$favicon = "static/git-favicon.png";

# git-diff-tree(1) options to use for generated patches
#@diff_opts = ("-M");
@diff_opts = ();

# 不显示 owner
$omit_owner = 1;

# 只显示 bare repo 中有 "git-daemon-export-ok" 这个文件的仓库
$export_ok = "git-daemon-export-ok";

# 语法高亮（需要 highlight 包）
$feature{'highlight'}{'default'} = [1];
</code></pre>

<p>向 <code>/srv/git/indextext.html</code> 中写入需要在主页中额外添加的文字</p>

<pre><code class="language-sh">echo 'My personal git repos' | sudo tee /srv/git/indextext.html
</code></pre>

<p>添加一个新的 nginx server block</p>

<pre><code class="language-nginx"># /etc/nginx/sites-available/git

server {
    server_name git.example.com;
    location /gitweb.cgi {
        root /usr/share/gitweb;
        gzip off;
        include fastcgi_params;
        fastcgi_param SCRIPT_NAME $uri;
        fastcgi_param GITWEB_CONFIG /etc/gitweb.conf;
        fastcgi_pass unix:/var/run/fcgiwrap.socket;
    }
    location / {
        root /usr/share/gitweb;
        index gitweb.cgi;
    }
}
</code></pre>

<p>最后 enable 并获取一个 SSL 证书</p>

<pre><code class="language-sh">sudo ln -sf /etc/nginx/sites-{available,enabled}/git
sudo certbot --nginx
sudo systemctl restart nginx
</code></pre>

<h2 id="http-clone">HTTP clone</h2>

<p>目的是允许任何人使用 <code>git clone https://git.example.com/clone/NAME</code> 对 gitweb 中显示的仓库进行 clone，为此使用 <a href="https://git-scm.com/docs/git-http-backend"><code>git-http-backend</code></a>。在
<code>/etc/nginx/sites-available/git</code> 的 <code>server</code> 块中加入</p>

<pre><code class="language-nginx">location ~ /clone(/.*) {
    client_max_body_size 0;
    include /etc/nginx/fastcgi_params;
    fastcgi_param SCRIPT_FILENAME /usr/lib/git-core/git-http-backend;
    fastcgi_param GIT_PROJECT_ROOT /srv/git;
    fastcgi_param PATH_INFO $1;
    fastcgi_pass unix:/var/run/fcgiwrap.socket;
}
</code></pre>

<p><code>git-http-backend</code> 会检查 bare repo 中是否有 <code>git-daemon-export-ok</code> 这个文件，如果没有则不允许 clone，这正好是 gitweb 配置中表示「公有仓库」使用的文件。如果想对所有的仓库都允许 clone，则可以添加一个 fastcgi param：</p>
<pre><code class="language-nginx">    fastcgi_param GIT_HTTP_EXPORT_ALL "";
</code></pre>

<p>这个 HTTP clone 只是一个只读的 clone，如果想要 push 还需使用 SSH。</p>

<h2 id="结果">结果</h2>

<p>创建一个测试仓库并标记为公开，再添加一个说明</p>

<pre><code class="language-sh">cd
git init --bare test.git
touch test.git/git-daemon-export-ok
echo 'Test repo' &gt; test.git/description
</code></pre>

<p>网页效果如下</p>

<p><img src="/images/7-git-server/test.git.png" alt="test.git" width="646px" class="align-center" /></p>

<p>Clone:</p>

<pre><code class="language-console">$ git clone https://git.example.com/clone/test
Cloning into 'test'...
warning: You appear to have cloned an empty repository.

$ ls -a test
.git
</code></pre>]]></content><author><name>weirane</name></author><category term="Tweaks" /><category term="git" /><category term="gitweb" /><category term="nginx" /><summary type="html"><![CDATA[Setup a Git server with web interface and HTTP clone]]></summary></entry><entry><title type="html">Fcitx5 安装记</title><link href="https://blog.ruo-chen.wang/2020/05/install-fcitx5.html" rel="alternate" type="text/html" title="Fcitx5 安装记" /><published>2020-05-03T00:00:00+08:00</published><updated>2024-09-11T11:08:25+08:00</updated><id>https://blog.ruo-chen.wang/2020/05/install-fcitx5</id><content type="html" xml:base="https://blog.ruo-chen.wang/2020/05/install-fcitx5.html"><![CDATA[<p>在 #archlinux-cn 上 fcitx 是个经常被讨论的话题，每次都有人推荐 fcitx5。但是因为只有在 KDE 中有图形化的配置工具就一直没有尝试。今天有人说配置工具 <code>kcm-fcitx5</code>
在非 KDE 中也可以安装了，所以来试试。</p>

<ul>
  <li>2021-01-29 更新：<code>kcm-fcitx5</code> 改名为 <code>fcitx5-configtool</code>（其实早就改了，只是博
  客里没更新）</li>
</ul>

<h2 id="安装">安装</h2>

<p>先卸载 fcitx4：</p>

<pre><code>pacman -Qsq fcitx | sudo pacman -Rsn -
</code></pre>

<p>安装 fcitx5：</p>

<pre><code>sudo pacman -S fcitx5 fcitx5-chinese-addons fcitx5-configtool fcitx5-qt fcitx5-gtk
</code></pre>

<p>Fcitx5 自带的皮肤不是很好看，我还安装了 <a href="https://github.com/hosxy/Fcitx5-Material-Color">material-color 皮肤</a>：</p>

<pre><code>sudo pacman -S fcitx5-material-color
</code></pre>

<h2 id="配置">配置</h2>

<h3 id="输入法">输入法</h3>

<p>有了图形化的配置工具，配置会轻松很多。首先在「输入法」一栏中添加需要的输入法，我使用的是双拼，然后在「附加组件」→「拼音」里面修改双拼方案为小鹤双拼。</p>

<h3 id="自动启动与环境变量">自动启动与环境变量</h3>

<p>把自动启动 fcitx 的命令改成 <code>fcitx5</code>。</p>

<p>我使用的图形管理是 X11。使用 fcitx4 的时候在 <code>~/.xprofile</code> 或者 <code>~/.xinitrc</code> 中设置的环境变量似乎不需要改成 fcitx5，之前 fcitx 使用的配置可以直接使用。</p>

<pre><code class="language-sh">export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS="@im=fcitx"
</code></pre>

<h2 id="体验">体验</h2>

<h3 id="快捷输入">快捷输入</h3>

<p>在输入法激活时使用分号键触发快捷输入。在 <code>/usr/share/fcitx5/data/quickphrase.d</code>
中有一些自带的快捷输入，包括 emoji 和一些 LaTeX 命令，可以转换部分 LaTeX 命令到对应的 unicode 字符，这个功能非常实用，可以让 LaTeX 文档更直观。当然也可以在配置工具中自定义快捷输入。</p>

<p><img src="/images/6-install-fcitx5/emoji.png" alt="emoji quick phrase" /></p>

<p><img src="/images/6-install-fcitx5/quickphrase.png" alt="LaTeX quick phrase" /></p>

<h3 id="单行模式">单行模式</h3>

<p>Fcitx5 自带的拼音可以使用单行模式，配合 material color 主题体验很好，有点
Windows 10 自带输入法的感觉。</p>

<p><img src="/images/6-install-fcitx5/blue.png" alt="material color blue" /><sup id="fnref:mc-fig"><a href="#fn:mc-fig" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></p>

<p>对于自带的拼音，在配置工具的「附加组件」→「拼音」中打开「可用时在应用程序中显示预编辑文本」，或者直接修改 <code>~/.config/fcitx5/conf/pinyin.conf</code>：</p>

<pre><code># 可用时在应用程序中显示预编辑文本
PreeditInApplicaation=True
</code></pre>

<p>可惜单行模式对使用 XIM 的程序不能使用 <sup id="fnref:no-xim"><a href="#fn:no-xim" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>，而我用的终端模拟器 alacritty 正好是使用的 XIM 😥<sup id="fnref:alacritty-xim"><a href="#fn:alacritty-xim" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>。不过单行模式算不上是刚需，也就无所谓了。</p>

<h2 id="总结">总结</h2>

<p>总的来说，fcitx5 的体验比 4 要好一些。配置选项简洁，配合 material color 皮肤界面也比较好看。<del>也可能只是我没有仔细研究 fcitx4 的配置</del></p>

<hr />
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:mc-fig">
      <p>图片来自 material color 的 <a href="https://github.com/hosxy/Fcitx5-Material-Color">GitHub 仓库</a>，使用 imagemagick
加了透明（<a href="https://stackoverflow.com/a/33541007/10974106">https://stackoverflow.com/a/33541007/10974106</a>）</p>
      <pre><code class="language-sh">convert blue.png -fuzz 20% -fill none -draw "color 1,1 floodfill" result.png
</code></pre>
      <p><a href="#fnref:mc-fig" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:no-xim">
      <p><a href="https://github.com/fcitx/fcitx5-chinese-addons/issues/3">https://github.com/fcitx/fcitx5-chinese-addons/issues/3</a> <a href="#fnref:no-xim" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:alacritty-xim">
      <p><a href="https://github.com/alacritty/alacritty/issues/44">https://github.com/alacritty/alacritty/issues/44</a> <a href="#fnref:alacritty-xim" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>weirane</name></author><category term="Tools" /><category term="fcitx" /><category term="imagemagick" /><summary type="html"><![CDATA[Installing fcitx5]]></summary></entry></feed>